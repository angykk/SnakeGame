package code;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;

import java.awt.Point;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;

import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.Timer;

public class Board extends JPanel implements ActionListener, KeyListener {
	// Angela Huang Winter 2022, Final Project, Western Canada High School
	
	final int boardx = 400; // width of jpanel
	final int boardy = 440; // length of jpanel
	
	final int boardStrip = 40; //length of the strip where "counter" will be displayed

	final int cellSize = 20; // size of each coordinate cell
	final int numCelly = (boardy - boardStrip) / cellSize; //number of cells on the y axis
	final int numCellx = boardx / cellSize; //number of cells on the x axis

	private Snake snake;//snake object
	private Apple apple;//apple object

	private static Timer timer;

	final int right = 1;
	final int left = 2;
	final int up = 3;
	final int down = 4;
	private int direction = right;
	
	private boolean collide = false;
	
	private int counter = 0; //apple counter

	public Board() {
		setPreferredSize(new Dimension(boardx, boardy));
		setBackground(Color.BLACK);
		setFocusable(true);

		snake = new Snake(3, numCellx, numCelly);
		apple = new Apple(numCellx, numCelly, snake.getPoints(), boardStrip, cellSize);

		timer = new Timer(150, this); //150 millisecond delay
		timer.start(); //game begins

		addKeyListener(this); //detects if a key is pressed on this panel
	}

	@Override //program calls when needed
	//https://docs.oracle.com/en/java/javase/13/docs/api/java.desktop/java/awt/Graphics.html
	public void paintComponent(Graphics g) {
		super.paintComponent(g);
		g.setColor(Color.white);
		
		g.drawString("Apples: " + counter, 0 , cellSize); //counter
		
		if(collide) {
			g.drawString("GAME OVER", boardx - boardx/5, cellSize);
		}

		for (int x = 0; x < snake.getPoints().size(); x ++) {
			Point p = snake.getPoints().get(x);
			g.fillRect(p.x * cellSize, p.y * cellSize, cellSize, cellSize);
		} //displays snake

		Point p = apple.getPoints();
		g.drawImage(apple.getApple(), cellSize * (p.x), cellSize * (p.y), cellSize, cellSize, this);

		// set colour of lines (R,G,B,OPACITY)
		g.setColor(new Color(255, 255, 255, 128));
		// horizontal lines
		for (int x = boardStrip/cellSize; x < numCelly + 1 + boardStrip/cellSize; x++) {
			int yPosition = x * cellSize;
			g.drawLine(0, yPosition, boardx, yPosition);
		}
		// vertical lines
		for (int x = 0; x < numCellx; x++) {
			int xPosition = x * cellSize;
			g.drawLine(xPosition, boardStrip, xPosition, boardy);
		}
	}
	
	public static void endGame() {
		timer.stop(); //stops game
	}

	public static void main(String[] args) {
		JFrame frame = new JFrame("Snake Game");
		frame.add(new Board());
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		frame.setVisible(true);
		frame.setResizable(false);
		frame.pack(); //minimum size of window while taking into account all components
	}

	@Override //auto generated by implementation (timer calls this method every 150 milliseconds)
	public void actionPerformed(ActionEvent e) {
		boolean shouldGrow = apple.getPoints().equals(snake.getHeadPoint()); 
		//checking if position of head is the same as the apple coordinate - therefore snake should grow
		counter = snake.grow(shouldGrow, apple, counter); //updating the counter as well as adding length to snake
		
		snake.movement(direction);
		
		if(snake.collide(numCellx, numCelly, boardStrip, cellSize)) {
			collide = true;
			endGame();
		}
		else {
			repaint(); //calls the paintComponent(g) method - repaints board (displays changes)
		}
		

	}

	@Override //auto generated by implementation (when keys are pressed, this is called)
	public void keyPressed(KeyEvent e) {
		int key = e.getKeyCode(); // https://docs.oracle.com/javase/tutorial/uiswing/events/keylistener.html
		
		if (key == KeyEvent.VK_UP && direction != down) {
			direction = up;
		} else if (key == KeyEvent.VK_DOWN && direction != up) {
			direction = down;
		} else if (key == KeyEvent.VK_LEFT && direction != right) {
			direction = left;
		} else if (key == KeyEvent.VK_RIGHT && direction != left) {
			direction = right;
		}
	}

	@Override //auto generated by implementation
	public void keyReleased(KeyEvent e) {
	}

	@Override //auto generated by implementation
	public void keyTyped(KeyEvent e) {
	}

}
